#!/usr/bin/env python
# Copyright 2015 Red Hat Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License"); you may
# not use this file except in compliance with the License. You may obtain
# a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations
# under the License.

""" Requires PyQt4 and python-netaddr
    sudo yum install -y PyQt4 python-netaddr

    This is a GUI tool, and should be run on the user's workstation, not on
    the undercloud itself.

    A simple UI to aid in configuring an RDO Manager undercloud.conf.
    Basic inputs are the provisioning network interface, the desired
    provisioning network CIDR, and the total number of overcloud nodes to be
    deployed.  It is best to overestimate the number of nodes to avoid having
    to change IP allocation ranges later.

    All values may be edited, but the tool does some basic sanity checks to
    verify such things as all IP ranges being on the same provisioning subnet,
    sufficient IP addresses in the provided ranges, and that no IP ranges
    overlap.

    Note that regenerating the advanced values will overwrite _all_ of the
    values, including any that may have been customized previously.

    The generated configuration may be used as undercloud.conf verbatim, or
    the values may be copied in to the sample configuration if other
    customization not included in the UI is desired.
"""

import sys

import netaddr
from PyQt4 import QtCore
from PyQt4 import QtGui


config_template = """# Config generated by undercloud wizard
# Use these values in undercloud.conf
[DEFAULT]
local_ip = %(local_ip)s
local_interface = %(local_interface)s
undercloud_public_vip = %(public_vip)s
undercloud_admin_vip = %(admin_vip)s
network_cidr = %(network_cidr)s
masquerade_network = %(masquerade_network)s
dhcp_start = %(dhcp_start)s
dhcp_end = %(dhcp_end)s
discovery_iprange = %(discovery_start)s,%(discovery_end)s
network_gateway = %(network_gateway)s
"""


class InvalidConfiguration(Exception):
    pass


class PairWidget(QtGui.QWidget):
    def __init__(self, label, widget, parent = None):
        super(PairWidget, self).__init__(parent)

        self.layout = QtGui.QHBoxLayout(self)
        self.layout.setContentsMargins(0, 0, 0, 0)

        self.label = label
        try:
            self.layout.addWidget(self.label)
        except TypeError:
            self.label = QtGui.QLabel(label)
            self.layout.addWidget(self.label)

        self.widget = widget
        self.layout.addWidget(self.widget)


class MainForm(QtGui.QMainWindow):
    # FIXME(bnemec): Adding an arbitrary 10 to the node count, to allow
    # for virtual ips.  This may not be enough for some setups.
    virtual_ips = 10
    # local_ip, public_vip, admin_vip
    undercloud_ips = 3

    def __init__(self):
        super(MainForm, self).__init__()

        self._setup_ui()
        self._generate_advanced_values()
        self.show()

    def _setup_ui(self):
        self.resize(600, 300)
        self.setWindowTitle('Undercloud Config Wizard')

        self.setCentralWidget(QtGui.QWidget())
        main_layout = QtGui.QVBoxLayout()
        self.centralWidget().setLayout(main_layout)
        self.error_dialog = QtGui.QErrorMessage.qtHandler()
        self.error_dialog.setWindowTitle('Invalid Configuration')

        basic_group = QtGui.QGroupBox('Basic Settings')
        basic_layout = QtGui.QVBoxLayout(basic_group)
        main_layout.addWidget(basic_group, 1)

        self.pxe_interface = QtGui.QLineEdit()
        self.pxe_interface.setText('eth1')
        basic_layout.addWidget(PairWidget('Provisioning Interface',
                                          self.pxe_interface))

        self.pxe_cidr = QtGui.QLineEdit()
        self.pxe_cidr.setText('192.0.2.0/24')
        basic_layout.addWidget(PairWidget('Provisioning CIDR',
                                          self.pxe_cidr))

        self.node_count = QtGui.QSpinBox()
        self.node_count.setValue(2)
        self.node_count.setMaximum(10000)
        basic_layout.addWidget(PairWidget('Overcloud Node Count',
                                          self.node_count))

        generate_advanced = QtGui.QPushButton('Generate Advanced')
        generate_advanced.setToolTip('Generate advanced option values based '
                                     'on the Basic values.')
        generate_advanced.clicked.connect(self._generate_advanced_values)
        main_layout.addWidget(generate_advanced)

        advanced_group = QtGui.QGroupBox('Advanced Settings')
        advanced_layout = QtGui.QVBoxLayout(advanced_group)
        main_layout.addWidget(advanced_group, 10)

        advanced_message = ('The generated defaults are intended to work for '
                            'most deployments, but any of the values below '
                            'may be edited.')
        advanced_label = QtGui.QLabel(advanced_message)
        advanced_label.setWordWrap(True)
        advanced_label.setSizePolicy(QtGui.QSizePolicy.Preferred,
                                     QtGui.QSizePolicy.Preferred)
        advanced_label.setMaximumSize(99999, 99999)
        advanced_label.setMinimumSize(0, 50)
        advanced_layout.addWidget(advanced_label)

        # Allons-y!
        ood_message = ('<div style="color:#f00">Advanced values may be out '
                       'of date.  Regeneration recommended.</div>')
        self.ood = QtGui.QLabel(ood_message)
        self.ood.hide()
        self.pxe_cidr.textEdited.connect(self.ood.show)
        self.node_count.valueChanged.connect(self.ood.show)
        advanced_layout.addWidget(self.ood)

        self.local_ip = QtGui.QLineEdit()
        advanced_layout.addWidget(PairWidget('Local IP',
                                             self.local_ip))
        self.network_gateway = QtGui.QLineEdit()
        advanced_layout.addWidget(PairWidget('Network Gateway',
                                             self.network_gateway))
        self.public_vip = QtGui.QLineEdit()
        advanced_layout.addWidget(PairWidget('Public VIP',
                                             self.public_vip))
        self.admin_vip = QtGui.QLineEdit()
        advanced_layout.addWidget(PairWidget('Admin VIP',
                                             self.admin_vip))

        self.dhcp_start = QtGui.QLineEdit()
        advanced_layout.addWidget(PairWidget('Provisioning DHCP Start',
                                             self.dhcp_start))
        self.dhcp_end = QtGui.QLineEdit()
        advanced_layout.addWidget(PairWidget('Provisioning DHCP End',
                                             self.dhcp_end))
        self.discovery_start = QtGui.QLineEdit()
        advanced_layout.addWidget(PairWidget('Discovery DHCP Start',
                                             self.discovery_start))
        self.discovery_end = QtGui.QLineEdit()
        advanced_layout.addWidget(PairWidget('Discovery DHCP End',
                                             self.discovery_end))

        generate_config = QtGui.QPushButton('Generate Config')
        generate_config.clicked.connect(self._generate_config)
        main_layout.addWidget(generate_config)


    def _invalid_configuration(self, message):
        # This should be qCritical, but there seems to be a bug
        # in that on my version of Qt that makes it show as a debug
        # message instead of critical.
        QtCore.qWarning(message)
        raise InvalidConfiguration(message)

    def _validate_count(self, node_count, cidr_ips, extra_ips):
        """Verify the ips in cidr_ips are sufficient for node_count

        :param node_count: The requested number of overcloud nodes.
        :param cidr_ips: A list of all the ips defined by the provisioning
            network cidr.
        :param extra_ips: An integer describing the number of additional ips
            that will be needed for the environment.  This may include things
            like virtual ips and the undercloud ip.
        """
        # node_count * 2 to allow for discovery range as well
        if len(cidr_ips) < node_count * 2 + extra_ips:
            message = 'Insufficient addresses available in provisioning CIDR'
            self._invalid_configuration(message)

    def _get_values(self):
        """Return a dict containing all UI values"""
        return {
            'local_ip': str(self.local_ip.text()),
            'local_interface': str(self.pxe_interface.text()),
            'public_vip': str(self.public_vip.text()),
            'admin_vip': str(self.admin_vip.text()),
            'network_cidr': str(self.pxe_cidr.text()),
            'masquerade_network': str(self.pxe_cidr.text()),
            'dhcp_start': str(self.dhcp_start.text()),
            'dhcp_end': str(self.dhcp_end.text()),
            'discovery_start': str(self.discovery_start.text()),
            'discovery_end': str(self.discovery_end.text()),
            'network_gateway': str(self.network_gateway.text()),
            'node_count': self.node_count.value(),
            }

    def _generate_advanced_values(self):
        values = self._get_values()
        cidr = netaddr.IPNetwork(values['network_cidr'])
        cidr_ips = list(cidr)
        node_count = values['node_count']
        self._validate_count(node_count, cidr_ips,
                             self.virtual_ips + self.undercloud_ips + 1)
        # 4 to allow room for two undercloud vips
        dhcp_start = 1 + self.undercloud_ips
        dhcp_end = dhcp_start + node_count + self.virtual_ips - 1
        discovery_start = dhcp_end + 1
        discovery_end = discovery_start + node_count - 1
        self._update_advanced_ui(cidr, cidr_ips, dhcp_start, dhcp_end,
                                 discovery_start, discovery_end)

    def _update_advanced_ui(self, cidr, cidr_ips, dhcp_start, dhcp_end,
                            discovery_start, discovery_end):
        """Method to isolate UI bits from the validation logic

        :param cidr: A netaddr.IPNetwork object representing the provisioning
            network.
        :param cidr_ips: A list of netaddr.IPAddress objects generated from
            the cidr parameter.
        All other params are indices into the cidr_ips list.
        """
        self.local_ip.setText('%s/%s' % (str(cidr_ips[1]), cidr.prefixlen))
        self.network_gateway.setText(str(cidr_ips[1]))
        self.public_vip.setText(str(cidr_ips[2]))
        self.admin_vip.setText(str(cidr_ips[3]))
        self.dhcp_start.setText(str(cidr_ips[dhcp_start]))
        self.dhcp_end.setText(str(cidr_ips[dhcp_end]))
        self.discovery_start.setText(str(cidr_ips[discovery_start]))
        self.discovery_end.setText(str(cidr_ips[discovery_end]))
        self.ood.hide()

    def _generate_config(self):
        dialog = QtGui.QDialog(self)
        layout = QtGui.QVBoxLayout()
        dialog.setLayout(layout)
        dialog.resize(800, 600)
        config_text = QtGui.QTextEdit()
        layout.addWidget(config_text)

        params = self._get_values()
        self._validate_config(params)

        config_text.setText(config_template % params)

        dialog.show()

    def _validate_config(self, params):
        """Validate an undercloud configuration described by params

        :param params: A dict containing all of the undercloud.conf option
            names mapped to their proposed values.
        """
        cidr = netaddr.IPNetwork(params['network_cidr'])
        cidr_ips = list(cidr)

        def validate_addr_in_cidr(params, name):
            if netaddr.IPAddress(params[name]) not in cidr_ips:
                message = ('%s "%s" not in defined CIDR "%s"' %
                           (name, params[name], cidr))
                self._invalid_configuration(message)

        params['just_local_ip'] = params['local_ip'].split('/')[0]
        validate_addr_in_cidr(params, 'just_local_ip')
        validate_addr_in_cidr(params, 'network_gateway')
        validate_addr_in_cidr(params, 'public_vip')
        validate_addr_in_cidr(params, 'admin_vip')
        validate_addr_in_cidr(params, 'dhcp_start')
        validate_addr_in_cidr(params, 'dhcp_end')
        validate_addr_in_cidr(params, 'discovery_start')
        validate_addr_in_cidr(params, 'discovery_end')

        # Validate dhcp range
        dhcp_start = netaddr.IPAddress(params['dhcp_start'])
        dhcp_end = netaddr.IPAddress(params['dhcp_end'])
        dhcp_start_index = cidr_ips.index(dhcp_start)
        dhcp_end_index = cidr_ips.index(dhcp_end)
        if dhcp_start_index >= dhcp_end_index:
            message = ('Invalid dhcp range specified, dhcp_start "%s" does '
                       'not come before dhcp_end "%s"' %
                       (dhcp_start, dhcp_end))
            self._invalid_configuration(message)
        # Validate discovery range
        discovery_start = netaddr.IPAddress(params['discovery_start'])
        discovery_end = netaddr.IPAddress(params['discovery_end'])
        discovery_start_index = cidr_ips.index(discovery_start)
        discovery_end_index = cidr_ips.index(discovery_end)
        if discovery_start_index >= discovery_end_index:
            message = ('Invalid discovery range specified, discovery_start '
                       '"%s" does not come before discovery_end "%s"' %
                       (discovery_start, discovery_end))
            self._invalid_configuration(message)
        # Validate the provisioning and discovery ip ranges do not overlap
        if (discovery_start_index >= dhcp_start_index and
            discovery_start_index <= dhcp_end_index):
            message = ('Discovery DHCP range start "%s" overlaps provisioning '
                       'DHCP range.' % discovery_start)
            self._invalid_configuration(message)
        if (discovery_end_index >= dhcp_start_index and
            discovery_end_index <= dhcp_end_index):
            message = ('Discovery DHCP range end "%s" overlaps provisioning '
                       'DHCP range.' % discovery_start)
            self._invalid_configuration(message)



if __name__ == '__main__':
    app = QtGui.QApplication(sys.argv)

    form = MainForm()

    sys.exit(app.exec_())
